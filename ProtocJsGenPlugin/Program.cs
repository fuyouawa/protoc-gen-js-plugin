using Google.Protobuf;
using Google.Protobuf.Compiler;
using Google.Protobuf.Reflection;
using System.Text;
using System.IO;
using System.Linq;
using System.Collections.Generic;

namespace ProtocJsGenPlugin;

class Program
{
    static void Main(string[] args)
    {
        // 从stdin读取整个请求数据
        using var stdin = Console.OpenStandardInput();
        using var stdout = Console.OpenStandardOutput();

        // 读取请求
        var request = CodeGeneratorRequest.Parser.ParseFrom(stdin);

        // 处理请求并生成响应
        var response = ProcessRequest(request);

        // 写入响应到stdout
        response.WriteTo(stdout);
    }

    static CodeGeneratorResponse ProcessRequest(CodeGeneratorRequest request)
    {
        var response = new CodeGeneratorResponse();

        foreach (var protoFile in request.ProtoFile)
        {
            // 只处理用户请求的文件，而不是所有依赖
            if (!request.FileToGenerate.Contains(protoFile.Name))
                continue;

            var fileContent = GenerateFileContent(protoFile);

            response.File.Add(new CodeGeneratorResponse.Types.File
            {
                Name = GetOutputFileName(protoFile.Name),
                Content = fileContent
            });
        }

        return response;
    }

    static string GetOutputFileName(string protoFileName)
    {
        // 将.proto扩展名替换为.mjs
        return Path.ChangeExtension(protoFileName, ".mjs");
    }

    static string GenerateFileContent(FileDescriptorProto protoFile)
    {
        var generator = new JsCodeGenerator(protoFile);
        return generator.Generate();
    }
}

internal static class StringExtensions
{
    /// <summary>
    /// 将snake_case转换为camelCase
    /// </summary>
    public static string SnakeToCamelCase(this string snakeCase)
    {
        if (string.IsNullOrEmpty(snakeCase))
            return snakeCase;

        var parts = snakeCase.Split('_');
        var result = new StringBuilder();

        for (int i = 0; i < parts.Length; i++)
        {
            var part = parts[i];
            if (string.IsNullOrEmpty(part))
                continue;

            if (i == 0)
            {
                // 第一个单词保持小写
                result.Append(part);
            }
            else
            {
                // 后续单词首字母大写
                result.Append(char.ToUpperInvariant(part[0]));
                if (part.Length > 1)
                    result.Append(part.Substring(1));
            }
        }

        return result.ToString();
    }

    /// <summary>
    /// 将snake_case转换为PascalCase
    /// </summary>
    public static string SnakeToPascalCase(this string snakeCase)
    {
        if (string.IsNullOrEmpty(snakeCase))
            return snakeCase;

        var parts = snakeCase.Split('_');
        var result = new StringBuilder();

        foreach (var part in parts)
        {
            if (string.IsNullOrEmpty(part))
                continue;

            result.Append(char.ToUpperInvariant(part[0]));
            if (part.Length > 1)
                result.Append(part.Substring(1));
        }

        return result.ToString();
    }
}

internal class JsCodeGenerator
{
    private readonly FileDescriptorProto _protoFile;
    private readonly StringBuilder _sb = new StringBuilder();
    private readonly Dictionary<string, string> _nestedClassNames = new Dictionary<string, string>();
    private readonly HashSet<string> _generatedNestedClasses = new HashSet<string>();

    public JsCodeGenerator(FileDescriptorProto protoFile)
    {
        _protoFile = protoFile;
    }

    public string Generate()
    {
        _sb.AppendLine("// Generated by protoc-gen-js-mjs");
        _sb.AppendLine($"// Source: {_protoFile.Name}");
        _sb.AppendLine();

        if (!string.IsNullOrEmpty(_protoFile.Package))
        {
            _sb.AppendLine($"// Package: {_protoFile.Package}");
            _sb.AppendLine();
        }

        // 生成枚举
        foreach (var enumType in _protoFile.EnumType)
        {
            GenerateEnum(enumType);
        }

        // 生成消息
        foreach (var messageType in _protoFile.MessageType)
        {
            GenerateMessage(messageType, "", _protoFile.Package ?? "");
        }

        return _sb.ToString();
    }

    private void GenerateEnum(EnumDescriptorProto enumType)
    {
        _sb.AppendLine($"// Enum: {enumType.Name}");
        _sb.AppendLine($"export const {enumType.Name} = {{");

        foreach (var value in enumType.Value)
        {
            _sb.AppendLine($"    {value.Name}: {value.Number},");
        }

        _sb.AppendLine("};");
        _sb.AppendLine();
    }

    private string GetIndependentClassName(string fullTypeName)
    {
        // 移除前导点
        if (fullTypeName.StartsWith("."))
            fullTypeName = fullTypeName.Substring(1);

        // 移除包名前缀
        if (!string.IsNullOrEmpty(_protoFile.Package) && fullTypeName.StartsWith(_protoFile.Package + "."))
        {
            fullTypeName = fullTypeName.Substring(_protoFile.Package.Length + 1);
        }

        // 将点替换为下划线
        string className = fullTypeName.Replace('.', '_');

        // 添加前缀以确保不与顶级类名冲突
        return "__" + className;
    }

    private void GenerateMessage(DescriptorProto messageType, string indent, string parentFullName)
    {
        var className = messageType.Name;
        var fullName = string.IsNullOrEmpty(parentFullName) ? className : $"{parentFullName}.{className}";
        var isTopLevel = string.IsNullOrEmpty(indent);

        if (!isTopLevel)
        {
            // 嵌套消息不应该通过这个方法生成
            return;
        }

        // 首先为所有嵌套消息生成独立类定义
        Dictionary<DescriptorProto, string> nestedIndependentClassNames = new Dictionary<DescriptorProto, string>();
        foreach (var nestedMessage in messageType.NestedType)
        {
            string independentClassName = GenerateNestedMessageClass(nestedMessage, fullName);
            nestedIndependentClassNames[nestedMessage] = independentClassName;
        }

        // 生成顶级导出类
        _sb.AppendLine($"{indent}// Message: {className}");
        _sb.AppendLine($"{indent}export class {className} {{");

        // 静态描述符
        _sb.AppendLine($"{indent}    static __descriptor = {{");
        _sb.AppendLine($"{indent}        name: \"{className}\",");
        _sb.AppendLine($"{indent}        fullName: \"{fullName}\",");
        _sb.AppendLine($"{indent}    }}");
        _sb.AppendLine();

        // 生成字段的getter/setter方法
        foreach (var field in messageType.Field)
        {
            GenerateFieldMethods(field, indent + "    ");
        }

        // 添加嵌套消息的静态引用
        foreach (var nestedMessage in messageType.NestedType)
        {
            string independentClassName = nestedIndependentClassNames[nestedMessage];
            _sb.AppendLine($"{indent}    static {nestedMessage.Name} = {independentClassName};");
        }

        // 生成嵌套枚举
        foreach (var nestedEnum in messageType.EnumType)
        {
            _sb.AppendLine();
            GenerateNestedEnum(nestedEnum, indent + "    ");
        }

        _sb.AppendLine($"{indent}}}");
        _sb.AppendLine();
    }

    private string GenerateNestedMessageClass(DescriptorProto messageType, string parentFullName)
    {
        var className = messageType.Name;
        var fullName = string.IsNullOrEmpty(parentFullName) ? className : $"{parentFullName}.{className}";

        // 如果已经生成，则返回独立类名
        if (_generatedNestedClasses.Contains(fullName))
        {
            return GetIndependentClassName(fullName);
        }

        _generatedNestedClasses.Add(fullName);

        // 生成独立类定义
        string independentClassName = GetIndependentClassName(fullName);
        _sb.AppendLine($"class {independentClassName} {{");

        // 静态描述符
        _sb.AppendLine($"    static __descriptor = {{");
        _sb.AppendLine($"        name: \"{className}\",");
        _sb.AppendLine($"        fullName: \"{fullName}\",");
        _sb.AppendLine($"    }}");
        _sb.AppendLine();

        // 生成字段的getter/setter方法
        foreach (var field in messageType.Field)
        {
            GenerateFieldMethods(field, "    ");
        }

        // 递归生成嵌套消息的独立类定义，并在当前类中添加静态引用
        foreach (var nestedMessage in messageType.NestedType)
        {
            string nestedIndependentClassName = GenerateNestedMessageClass(nestedMessage, fullName);
            // 在当前类中添加静态引用
            _sb.AppendLine($"    static {nestedMessage.Name} = {nestedIndependentClassName};");
        }

        // 生成嵌套枚举（保持不变）
        foreach (var nestedEnum in messageType.EnumType)
        {
            _sb.AppendLine();
            GenerateNestedEnum(nestedEnum, "    ");
        }

        _sb.AppendLine($"}}");
        _sb.AppendLine();

        return independentClassName;
    }

    private void GenerateNestedEnum(EnumDescriptorProto enumType, string indent)
    {
        _sb.AppendLine($"{indent}// Nested enum: {enumType.Name}");
        _sb.AppendLine($"{indent}static {enumType.Name} = {{");

        foreach (var value in enumType.Value)
        {
            _sb.AppendLine($"{indent}    {value.Name}: {value.Number},");
        }

        _sb.AppendLine($"{indent}}};");
    }

    private void GenerateFieldMethods(FieldDescriptorProto field, string indent)
    {
        var fieldName = field.Name;
        var camelCaseName = fieldName.SnakeToCamelCase();
        var pascalCaseName = fieldName.SnakeToPascalCase();

        // 检查是否是oneof字段
        bool isOneofField = field.HasOneofIndex && field.OneofIndex >= 0;

        if (isOneofField)
        {
            _sb.AppendLine($"{indent}// Oneof field (index: {field.OneofIndex})");
        }

        // 字段类型映射
        var jsType = GetJsType(field);

        // Getter方法
        _sb.AppendLine($"{indent}/** @return {{{jsType}}} */");
        _sb.AppendLine($"{indent}get{GetMethodName(field)}() {{");
        _sb.AppendLine($"{indent}    return this.{fieldName};");
        _sb.AppendLine($"{indent}}}");
        _sb.AppendLine();

        // Setter方法
        _sb.AppendLine($"{indent}/** @param {{{jsType}}} value */");
        _sb.AppendLine($"{indent}set{GetMethodName(field)}(value) {{");
        _sb.AppendLine($"{indent}    this.{fieldName} = value;");
        _sb.AppendLine($"{indent}}}");

        // 如果不是最后一个字段，添加空行
        _sb.AppendLine();
    }


    private string GetMethodName(FieldDescriptorProto field)
    {
        return field.Name.SnakeToPascalCase();
    }

    private string GetJsType(FieldDescriptorProto field)
    {
        var baseType = GetBaseJsType(field);

        // 处理repeated字段（数组）
        if (field.Label == FieldDescriptorProto.Types.Label.Repeated)
        {
            // 检查是否是map（proto中的map会被表示为repeated的特定消息类型）
            if (IsMapField(field))
            {
                var mapTypes = GetMapKeyValueTypes(field);
                return $"Map<{mapTypes.keyType}, {mapTypes.valueType}>";
            }
            else
            {
                return $"{baseType}[]";
            }
        }

        // 处理optional字段（proto3中所有字段都是可选的，但我们可以标记为可能为null）
        // 对于标量类型，在JS中可以是undefined
        return baseType;
    }

    private string GetBaseJsType(FieldDescriptorProto field)
    {
        switch (field.Type)
        {
            case FieldDescriptorProto.Types.Type.Double:
            case FieldDescriptorProto.Types.Type.Float:
                return "number";

            case FieldDescriptorProto.Types.Type.Int64:
            case FieldDescriptorProto.Types.Type.Uint64:
            case FieldDescriptorProto.Types.Type.Int32:
            case FieldDescriptorProto.Types.Type.Fixed64:
            case FieldDescriptorProto.Types.Type.Fixed32:
            case FieldDescriptorProto.Types.Type.Uint32:
            case FieldDescriptorProto.Types.Type.Sfixed32:
            case FieldDescriptorProto.Types.Type.Sfixed64:
            case FieldDescriptorProto.Types.Type.Sint32:
            case FieldDescriptorProto.Types.Type.Sint64:
                return "number";

            case FieldDescriptorProto.Types.Type.Bool:
                return "boolean";

            case FieldDescriptorProto.Types.Type.String:
                return "string";

            case FieldDescriptorProto.Types.Type.Bytes:
                return "Uint8Array";

            case FieldDescriptorProto.Types.Type.Enum:
                return field.TypeName.Split('.').Last();

            case FieldDescriptorProto.Types.Type.Message:
                return GetMessageTypeName(field.TypeName);

            default:
                return "any";
        }
    }

    private bool IsMapField(FieldDescriptorProto field)
    {
        // 简单判断：如果是repeated消息类型，并且类型名包含"Entry"，可能是map
        // 更准确的实现需要检查消息是否有key和value字段
        return field.Type == FieldDescriptorProto.Types.Type.Message &&
               field.Label == FieldDescriptorProto.Types.Label.Repeated &&
               field.TypeName?.Contains("Entry") == true;
    }

    private (string keyType, string valueType) GetMapKeyValueTypes(FieldDescriptorProto field)
    {
        // 简化实现：返回通用的类型
        // 实际应该解析消息结构获取key和value类型
        return ("string", "any");
    }

    private string GetMessageTypeName(string typeName)
    {
        // 移除开头的"."，因为proto类型名以"."开头表示绝对路径
        if (typeName.StartsWith("."))
            typeName = typeName.Substring(1);

        // 检查是否是当前文件中的嵌套消息
        // 如果类型名包含点（除了包名之外的点），则可能是嵌套消息
        if (!string.IsNullOrEmpty(_protoFile.Package) && typeName.StartsWith(_protoFile.Package + "."))
        {
            // 去掉包名部分
            string withoutPackage = typeName.Substring(_protoFile.Package.Length + 1);
            // 如果去掉包名后仍包含点，说明是嵌套消息
            if (withoutPackage.Contains('.'))
            {
                // 返回独立类名
                return GetIndependentClassName(typeName);
            }
        }

        // 返回类型名（简化处理，实际可能需要处理嵌套）
        return typeName.Split('.').Last();
    }
}